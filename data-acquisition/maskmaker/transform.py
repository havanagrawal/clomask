"""Standardize directory structure for images and masks

The images generated by LabelMe can either have polygons or masks. this script
creates a standardized directory structure to be consumed later:

images
 |- [image_id]
   |- image
       |- [image_id].jpg
   |- masks
       |- mask_001.png
       |- mask_002.png
       |- mask_003.png
       |- ...

The top level directory name can be passed as an argument.
"""

import os
import glob
import json
import logging
import shutil as sh

from argparse import ArgumentParser

from maskmaker import ImageMask

logging.basicConfig(format=logging.BASIC_FORMAT, level=logging.INFO)

WHITE = (255, 255, 255)
RED = (255, 0, 0)
BLACK = (0, 0, 0)

def get_masks_for(mask_path, image_id):
    """In case we have masks instead of polygons, return the mask file paths"""
    return glob.glob(os.path.join(mask_path, image_id + "*"))


def _make_dirs(dest_dir, image_id):
    """Create the directories for this image ID"""
    dirs_to_make = {
        "image_dir": os.path.join(dest_dir, image_id, "train_image"),
        "mask_dir": os.path.join(dest_dir, image_id, "train_mask")
    }

    for dir_to_make in dirs_to_make.values():
        os.makedirs(dir_to_make, exist_ok=True)

    return dirs_to_make


def parse_args():
    """Parse arguments from the command line"""
    parser = ArgumentParser(description="Standardize the directory structure for labeled data from LabelMe")
    parser.add_argument("--root", required=True, help="Absolute path to the unzipped directory as downloaded from LabelMe")
    parser.add_argument("--user", required=False, default="havanagrawal", help="The username who labeled the data on LabelMe")
    parser.add_argument("--cname", required=False, default="bottles", help="The name of the collection on LabelMe")
    parser.add_argument("--dest", required=False, default="images", help="The top level directory in the output. Consider naming this either 'train' or 'test'")
    parser.add_argument("--class-map-file", required=False, default="./class_map.json", help="The JSON file containing the class to ID mapping")

    return parser.parse_args()

def main(args):
    image_path = os.path.join(args.root, "Images", "users", args.user, args.cname)
    annotation_path = os.path.join(args.root, "Annotations", "users", args.user, args.cname)
    mask_path = os.path.join(args.root, "Masks", "users", args.user, args.cname)

    logging.info("Using image path:\t\t%s", image_path)
    logging.info("Using annotation path:\t%s", annotation_path)
    logging.info("Using mask path:\t\t%s", mask_path)

    image_ids = {s.split(".")[0] for s in os.listdir(image_path)}
    logging.info("Found %d images", len(image_ids))

    class_map = json.load(open(args.class_map_file))

    for img_id in image_ids:
        # Create necessary directories
        dirs = _make_dirs(args.dest, img_id)

        # Generate names according to desired naming convention
        image_file = img_id + ".jpg"
        image_filepath = os.path.join(image_path, image_file)
        xml_filepath = os.path.join(annotation_path, img_id + ".xml")

        # Read the XML with polygons and generate masks
        imask = ImageMask(xml_filepath, class_map=class_map, img_color=BLACK, polygon_fill=WHITE)

        # Save mask files to appropriate location
        if not imask.polygons:
            logging.error("Old format of masks is unsupported. Please use the polygon tool to make masks for %s", image_file)
            continue

        imask.save_masks(dirs["mask_dir"])

        # Move image files to the desired location
        sh.copy(image_filepath, dirs["image_dir"])

if __name__ == "__main__":
    main(parse_args())
